


In this folder are placed the embedded objects, or embOBJs for short, which are used for cross-platform development 
under a number of architectures: arm, dspic33, linux, windows.

The embOBJs are a collection of cross-platform objects written in C which are used to write the application on the EMS, 
on the 6SG and part of code in the PC104. In particular, the PC104 shares with the EMS the code used for UDP protocol 
communication.

In this folder are grouped all the embOBJs used in the above three platform. This document describes the tree structure
of the folder.  


To understand the grouping it is important to understand the meaning of the term execution-environment. 
Most of the embOBJs are indeed cross-platform, but need some services (for instance thread-synchronization or 
timing services) which depend heavily on the platform they run. Those services are provided by the execution-environment.

The keep most of the object platform-independent it is used the so called virtual-execution-environment (or vee) which 
contains objects which offer only the interface to the service, but not the actual service.  
The service is offered by passing to the vee objects the pointer of an object fit to the execution environment of the platform.

As an example, the EOfifo protects concurrent read/write operations using methods of the virtual object EOVmutex on a void pointer. 
When used on the EMS the EOfifo initialises its void pointer with a pointer to EOMmutex and when used on the 6SG with a pointer to 
EOSmutex. These derived objects use the protection offered by their execution environment: EOmutex uses OSAL, EOSmutex uses a simple 
ISR disable/enable

In general on a platoform we have the vee and one of the following: (1) multitasking ee (or mee) where inside a MPU we have OSAL running 
as in the EMS; (2) YARP ee (or yee) if we have access to YARP/ACE services as inside the PC104; (3) singletask ee (or see) if we use a 
super-loop approach as in the 6SG; (4) no ee (or nee) if the services are simply NOT given at all. 


In relation with the execution environment we thus have the following prefix for objects: 
- EOxxx object usable in any platform, but they may need service of some EOVxxx object. 
- EOVxxx objects usable in any platform which offer interface to objects running on a specific execution-environment.
- EOMxxx objects running on the multi-tasking execution environment using OSAL.
- EOSxxx objects running on the singe-tasking execution environment using the super-loop.
- EOYxxx objects running on the YARP/ACE execution environment.
- EONxxx objects running without an execution environment.  
  
  
The objects in this folder are grouped by function and by execution-environment. Each sub-folder contains a set of homogeneous objects for a given
execution environment.  


Here is a brief description of the content of the sub-folders:

- core              *
  contains core objects which are needed by most applications: the singleton memory pool EOtheMemoryPool, the singleton error manager EOtheErrorManager, 
  some containers (EOfifo, EOdeque, EOlist, etc.), timer EOtimer, action EOaction.  
  When these objects need a service from a specific execution-environment they refer only to vee objects (found elsewhere).

- core-vee          * 
  contains virtual objects which offer just an interface but need to be called with a pointer to a derived object: EOVmutex, EOVtask, the 
  singleton callback manager EOVtheCallbackManager, the singleton system services EOVtheSystem, the singleton timer manager EOVtheTimerManager.
  
- core-nee
  contains objects derived from those in core-vee using ... nothing.  It is a trick to make a project compile when no service of core-vee is
  really required.  
  
- core-see
  contains objects derived from those in core-vee using a super-loop approach with events from a ISR timer tick. This approach has been used 
  for the 6SG board where we preferred keeping a single thread activity.
  
- core-mee
  contains objects derived from those in core-vee using OSAL, the RTOS abstraction layer running on ARM (but possibly on any MPU):
  EOMmutex, EOMtask, EOMtheCallbackManager, EOMtheSystem, EOMtheTimerManager.

- core-yee
  contains objects derived from those in core-vee using using YARP or ACE.
  
- ipnet             *
  contains objects used for IP network activity: EOpacket, EOsocket, EOsocketDatagram, and the singleton virtual EOVtheIPnet.

- ipnet-mee
  contains the derived IPnet EOMtheIPnet implemented using OSAL and IPAL, thus running on ARM (but possibly on any MPU).
  
- mc
  contains the objects used for motion control on the EMS: EOaxisControl, EOdecoupler, EOemsController, EOpid, EOspeedmeter, EOtrajectory.

- prot              *
  contains objects used for UDP protocol communication: EOtransmitter, EOreceiver, EOtransceiver, EOnv, EOtheParser, EOtheFormer, the
  configuration of the protocol EOnvsCfg, etc.

- utils             *
  contains utility objects such as: state machine EOsm and EOumlsm, the ETH parser eOTheEthLowLevParser, etc.
  
- env
  contains objects which interact with the shared-services in EMS and retrieve/set environment information about board, partition table, network, etc.

- icub              *
  contains header files which specify data types used in iCub about measurement units, motion control, analog sensors, skin, management, diagnostics, etc..  

- icub-app          
  contains objects which implement a generic EMS application: the singleton EOMtheEMSappl, its configuration EOMtheEMSapplCfg, 
  its sub-parts (EOMtheEMSconfigurator, EOMtheEMSrunner, EOMtheEMSerror, EOMtheEMStransceiver, EOMtheEMSsocket), other services such as EOMtheEMSbackdoor 
  and the EOMtheEMSdiscoverylistener, etc.

- icub-nvscfg       *
  contains files with data structures used by EOnvsCfg to configure the UDP protocol for every EMS board in iCub.

- icub-ems
  contains objects used by the EMS for manipulation of CAN protocol of attached boards. 
  

  
These sub-folders are used by PC104, EMS and 6SG in the following way:

        

PC104:  core, core-vee, core-yee, ipnet,                prot, utils,      icub,           icub-nvscfg.

EMS:    core, core-vee, core-mee, ipnet, ipnet-mee, mc, prot, utils, env, icub, icub-app, icub-nvscfg, icub-ems. 

6SG:    core, core-vee, core-see.   





A new different tree could be:

common      ----                    (pc104, ems, 6sg) (+4dc)
                |-core
                |-core-vee
                |-utils            

arm-ee      ----                    (ems) (+4dc)
                |-core-mee
                
ems-appl    ----                    (ems) ... think how to split and allow 4dc to share things (ipnet, ipnet-mee, mc, env, icub-something)               
                |-ipnet
                |-ipnet-mee
                |-mc
                |-env
                |-icub-app
                |-icub-ems            

udp-prot    ----                    (ems) ... and 4dc? hopefully the same things on new protocol
                |-prot
                |-icub
                |-icub-nvscfg
            
pc104-ee    ----                    (pc104)
                |-core-yee
         
         
6sg-ee      ----                    (6sg)
                |-core-see

                
comments:   
    1. move EOsm and EOumlsm in core ! -> no effect but it belongs to there as it is really independent from all.
    2. move EOpacket in core ! -> effect is that we don't include ipnet in udp-prot and we keep it in ems-only (less files in pc104). 
    
with new tree organisation icubmod/emBODY would link only (a) common, (b) udp-prot, (c) pc104-ee 

However ... the section udp-prot shall change.


